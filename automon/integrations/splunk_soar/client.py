import json
import functools

from typing import Optional

from automon.log import Logging
from automon.integrations.requests import Requests

from .rest import Urls
from .artifact import Artifact
from .container import Container
from .config import SplunkSoarConfig
from .response import Response

log = Logging(name='SplunkSoarClient', level=Logging.DEBUG)
Logging(name='RequestsClient', level=Logging.DEBUG)


class SplunkSoarClient:
    def __init__(self, host: str = None,
                 user: str = None,
                 password: str = None,
                 config: SplunkSoarConfig = None):
        """Splunk SOAR Client"""

        self.config = config or SplunkSoarConfig(host=host, user=user, password=password)
        self.client = Requests(headers=self.config.headers)

        self.action_run = None
        self.app = None
        self.app_run = None
        self.asset = None
        self.cluster_node = None
        self.containers = None
        self.playbook_run = None

    def __repr__(self) -> str:
        return f'{self.__dict__}'

    def _content(self) -> bytes:
        """get result"""
        if self.client.results:
            return self.client.results.content
        return b''

    def _content_dict(self) -> dict:
        """convert request.content to dict"""
        if self._content():
            return json.loads(self._content())
        return {}

    def _get(self, url: str) -> bool:
        """send get request"""
        return self.client.get(url=url, headers=self.client.headers)

    def _isConnected(func):
        @functools.wraps(func)
        def wrapper(self, *args, **kwargs):
            if self.config.isReady():
                return func(self, *args, **kwargs)
            return False

        return wrapper

    def _delete(self, url: str) -> bool:
        """send get request"""
        return self.client.delete(url=url, headers=self.client.headers)

    def _post(self, url: str, data: dict) -> bool:
        """send post request"""
        return self.client.post(url=url, headers=self.client.headers, data=data)

    @_isConnected
    def create_artifact(
            self,
            container_id,
            cef=None,
            cef_types=None,
            data=None,
            description=None,
            end_time=None,
            ingest_app_id=None,
            kill_chain=None,
            label=None,
            name=None,
            owner_id=None,
            run_automation=None,
            severity=None,
            source_data_identifier=None,
            start_time=None,
            tags=None,
            type=None,
            *args, **kwargs) -> Artifact:
        """Create artifact"""

        artifact = Artifact(
            dict(cef=cef,
                 cef_types=cef_types,
                 container_id=container_id,
                 data=data,
                 description=description,
                 end_time=end_time,
                 ingest_app_id=ingest_app_id,
                 kill_chain=kill_chain,
                 label=label,
                 name=name,
                 owner_id=owner_id,
                 run_automation=run_automation,
                 severity=severity,
                 source_data_identifier=source_data_identifier,
                 start_time=start_time,
                 tags=tags,
                 type=type)
        )

        if self._post(Urls.artifact(*args, **kwargs), data=artifact.to_json()):
            if self.client.results.status_code == 200:
                id = self.client.to_dict()['id']
                log.info(f'artifact created. {artifact} {self.client.to_dict()}')
                return self.list_artifact(artifact_id=id)
            else:
                existing_artifact_id = self.client.to_dict()['existing_artifact_id']
                log.info(f'artifact exists. {artifact} {self.client.to_dict()}')
                return self.list_artifact(artifact_id=existing_artifact_id)

        log.error(f'create artifact. {self.client.to_dict()}', enable_traceback=False)
        return False

    @_isConnected
    def create_container(
            self,
            label,
            name,
            artifacts=None,
            asset_id=None,
            close_time=None,
            custom_fields=None,
            data=None,
            description=None,
            due_time=None,
            end_time=None,
            ingest_app_id=None,
            kill_chain=None,
            owner_id=None,
            role_id=None,
            run_automation=None,
            sensitivity=None,
            severity=None,
            source_data_identifier=None,
            start_time=None,
            open_time=None,
            status=None,
            tags=None,
            tenant_id=None,
            container_type=None,
            template_id=None,
            authorized_users=None,
            *args, **kwargs) -> Container:
        """Create container"""

        container = Container(
            dict(label=label,
                 name=name,
                 artifacts=artifacts,
                 asset_id=asset_id,
                 close_time=close_time,
                 custom_fields=custom_fields,
                 data=data,
                 description=description,
                 due_time=due_time,
                 end_time=end_time,
                 ingest_app_id=ingest_app_id,
                 kill_chain=kill_chain,
                 owner_id=owner_id,
                 role_id=role_id,
                 run_automation=run_automation,
                 sensitivity=sensitivity,
                 severity=severity,
                 source_data_identifier=source_data_identifier,
                 start_time=start_time,
                 open_time=open_time,
                 status=status,
                 tags=tags,
                 tenant_id=tenant_id,
                 container_type=container_type,
                 template_id=template_id,
                 authorized_users=authorized_users)
        )

        if self._post(Urls.container(*args, **kwargs), data=container.to_json()):
            if self.client.results.status_code == 200:
                id = self.client.to_dict()['id']
                log.info(f'container created. {container} {self.client.to_dict()}')
                return self.get_container(container_id=id)
        log.error(f'create container. {self.client.to_dict()}', enable_traceback=False)
        return False

    @_isConnected
    def delete_container(self, container_id, *args, **kwargs):
        """Delete containers"""
        assert isinstance(container_id, int)

        if self._delete(Urls.container(identifier=container_id, *args, **kwargs)):
            if self.client.results.status_code == 200:
                log.info(f'container deleted: {container_id}')
                return True
        log.error(f'delete container: {container_id}. {self.client.to_dict()}', enable_traceback=False)
        return False

    def isConnected(self) -> bool:
        """check if client can connect"""
        if self.config.isReady():
            if self._get(Urls.container()):
                log.info(f'client connected '
                         f'{self.config.host} '
                         f'[{self.client.results.status_code}] ')
                return True

        else:
            log.warn(f'client not connected')
        return False

    @_isConnected
    def get_artifact(self, artifact_id: int = None, **kwargs) -> Artifact:
        """list action run"""
        if self._get(Urls.artifact(identifier=artifact_id, **kwargs)):
            artifact = Artifact(self._content_dict())
            log.info(f'get artifact: {artifact}')
            return artifact

        log.error(f'artifact not found: {artifact_id}', enable_traceback=False)
        return Artifact()

    @_isConnected
    def get_container(self, container_id: int = None, **kwargs) -> Container:
        if self._get(Urls.container(identifier=container_id, **kwargs)):
            container = Container(self._content_dict())
            log.info(f'get container: {container}')
            return container

        log.error(f'container not found: {container_id}', enable_traceback=False)
        return Container()

    @_isConnected
    def list_artifact(self, artifact_id: int = None, **kwargs) -> Response:
        """list action run"""
        if self._get(Urls.artifact(identifier=artifact_id, **kwargs)):
            response = Response(self._content_dict())
            return response
        return Response()

    @_isConnected
    def list_action_run(self, **kwargs) -> bool:
        """list action run"""
        if self._get(Urls.action_run(**kwargs)):
            self.containers = self._content_dict()
            return True
        return False

    @_isConnected
    def list_app(self, **kwargs) -> bool:
        """list app"""
        if self._get(Urls.app(**kwargs)):
            self.app = self._content_dict()
            return True
        return False

    @_isConnected
    def list_app_run(self, **kwargs) -> bool:
        """list app run"""
        if self._get(Urls.app_run(**kwargs)):
            self.app_run = self._content_dict()
            return True
        return False

    @_isConnected
    def list_artifacts(self,
                       page: int = None,
                       page_size: int = 1000, **kwargs) -> Response:
        """list artifacts"""
        if self._get(Urls.artifact(page=page, page_size=page_size, **kwargs)):
            response = Response(self._content())
            log.info(f'list artifacts: {len(response.data)}')
            return response
        return Response()

    @_isConnected
    def list_artifact_generator(self,
                                page: int = 0,
                                page_size: int = None, **kwargs) -> [Container]:
        """Generator for paging through artifacts"""

        page = page

        while True:
            response = self.list_containers(page=page, page_size=page_size, **kwargs)
            if response.data:
                containers = [Container(x) for x in response.data]
                num_pages = response.num_pages
                log.info(f'{page}/{num_pages} ({round(page / num_pages * 100, 2)}%)')

                if page > num_pages:
                    log.info(f'list container finished')
                    return True

                yield containers
                page += 1

            elif response.data == []:
                log.info(f'{page}/{num_pages} ({round(page / num_pages * 100, 2)}%)')
                log.info(f'list container finished. {response}')
                return True

            elif response.data is None:
                log.error(f'list container failed', enable_traceback=True)
                return False

            else:
                log.info(f'no containers. {response}')
                return True

        return False

    @_isConnected
    def list_asset(self, **kwargs) -> Response:
        """list asset"""
        if self._get(Urls.asset(**kwargs)):
            response = Response(self._content_dict())
            log.info(f'list assets: {len(response.data)}')
            return response
        return Response()

    @_isConnected
    def list_containers(self,
                        page: int = None,
                        page_size: int = 1000,
                        *args, **kwargs) -> Response:
        """list containers"""

        url = Urls.container(page=page, page_size=page_size, *args, **kwargs)
        if self._get(url):
            response = Response(self._content_dict())
            log.info(f'list containers: {len(response.data)}')
            return response
        log.error(f'no containers', enable_traceback=False)
        return Response()

    @_isConnected
    def list_containers_generator(self,
                                  page: int = 0,
                                  page_size: int = None, **kwargs) -> [Container]:
        """Generator for paging through containers"""

        page = page

        while True:
            response = self.list_containers(page=page, page_size=page_size, **kwargs)
            if response.data:
                containers = [Container(x) for x in response.data]
                num_pages = response.num_pages
                log.info(f'container page {page}/{num_pages} ({round(page / num_pages * 100, 2)}%)')

                if page > num_pages:
                    log.info(f'list container finished')
                    return True

                yield containers
                page += 1

            elif response.data == []:
                log.info(f'{page}/{num_pages} ({round(page / num_pages * 100, 2)}%)')
                log.info(f'list container finished. {response}')
                return True

            elif response.data is None:
                log.error(f'list container failed', enable_traceback=True)
                return False

            else:
                log.info(f'no containers. {response}')
                return True

        return False

    @_isConnected
    def list_cluster_node(self, **kwargs) -> bool:
        """list cluster node"""
        if self._get(Urls.cluster_node(**kwargs)):
            self.cluster_node = self._content_dict()
            return True
        return False

    @_isConnected
    def list_playbook_run(self, **kwargs) -> bool:
        """list cluster node"""
        if self._get(Urls.playbook_run(**kwargs)):
            self.playbook_run = self._content_dict()
            return True
        return False

    @_isConnected
    def list_vault(self, identifier=None, **kwargs) -> bool:
        """list cluster node"""
        if self._get(Urls.vault(identifier=identifier, **kwargs)):
            self.playbook_run = self._content_dict()
            return True
        return False
